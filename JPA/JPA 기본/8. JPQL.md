> * 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
> * SQL을 추상화해서 특정 데이터베이스 SQL에 의존X
> * JPQL은 결국 SQL로 변환된


### JPQL 문법
* select m from Member as m where m.age > 18 
* 엔티티와 속성은 대소문자 구분O (Member, age)
* JPQL 키워드는 대소문자 구분X (SELECT, FROM, where)
* 엔티티 이름 사용, 테이블 이름이 아님(Member)
* 별칭은 필수(m) (as는 생략가능)


<br>

### 결과 반환
* 반환 타입 
    * TypeQuery: 반환 타입이 명확할 때 사용
TypedQuery<Member> query =
 em.createQuery("SELECT m FROM Member m", Member.class); 
    * Query: 반환 타입이 명확하지 않을 때 사용
```java
TypedQuery<Member> query =
 em.createQuery("SELECT m FROM Member m", Member.class); 
Query query = 
 em.createQuery("SELECT m.username, m.age from Member m"); 
 ```
* 결과 조회
   * query.getResultList(): 결과가 하나 이상일 때, 리스트 반환
        * 결과가 없으면 빈 리스트 반환
    * query.getSingleResult(): 결과가 정확히 하나, 단일 객체 반환      
         * 결과가 없으면: javax.persistence.NoResultException
         * 둘 이상이면: javax.persistence.NonUniqueResultException


<br>

### 파라미터 바인딩
```java
Member result = em.createQuery("select m form Member m where m.username = :username", Member.class)
          .setParameter("username", "member1")
          .getSinlgeResult();
```

<br>


### 프로젝션
* SELECT m FROM Member m -> 엔티티 프로젝션
* SELECT m.team FROM Member m -> 엔티티 프로젝션
* SELECT m.address FROM Member m -> 임베디드 타입 프로젝션
* SELECT m.username, m.age FROM Member m -> 스칼라 타입 프로젝션
```java
//다른 경우에는 List로 반환하면 되지만, 타입이 여러 개인 스칼라 타입의 경우 List로 반환하면 복잡해지기 때문에 별도의 dto를 생성하여 반환
List<MemberDTO> result = em.createQuery("select new jpql.MemberDto(m.username, m.age) from Member m", MemberDTO.class)
    .getResultList();
MemberDTO memberDTO = result.get(0);
Stirng username = memberDTO.getUsername();
int age = memberDTO.getAge();
```

<br>


### 페이징 API
* setFirstResult(int startPosition) : 조회 시작 위치(0부터 시작)
* setMaxResults(int maxResult) : 조회할 데이터 수
```java
 String jpql = "select m from Member m order by m.name desc";
 List<Member> resultList = em.createQuery(jpql, Member.class)
    .setFirstResult(10)
    .setMaxResults(20)
    .getResultList();
 ```

<br>

 ### JOIN
* 내부 조인:
```java
SELECT m FROM Member m [INNER] JOIN m.team t
 ```
* 외부 조인:
 ```java
SELECT m FROM Member m LEFT [OUTER] JOIN m.team t
 ```
* 세타 조인: 연관관계가 없는 값들을 where문에 넣어 가져옴
 ```java
select count(m) from Member m, Team t where m.username = t.name
 ``` 
* ON 절
     *  조인 대상 필터링 
     * 연관관계가 없는 엔티티 외부 조인
```java
SELECT m FROM Member m LEFT JOIN m.team t ON t.name='A'
SELECT m, t FROM Member m LFET JOIN Team t ON m.username = t.name
``` 

<br>


### 서브쿼리
* [NOT] EXISTS (subquery): 서브쿼리에 결과가 존재하면 참
* {ALL | ANY | SOME} (subquery)
     * ALL 모두 만족하면 참
     * ANY, SOME: 같은 의미, 조건을 하나라도 만족하면 참
* [NOT] IN (subquery): 서브쿼리의 결과 중 하나라도 같은 것이 있으면 참

```java
//나이가 평균보다 많은 회원
select m from Member m
where m.age > (select avg(m2.age) from Member m2) 
```

```java
//전체 상품 각각의 재고보다 주문량이 많은 주문들
select o from Order o 
where o.orderAmount > ALL (select p.stockAmount from Product p) 
```

<br>

### JPQL 타입 표현
* 문자: ‘HELLO’, ‘She’’s’
* 숫자: 10L(Long), 10D(Double), 10F(Float)
* Boolean: TRUE, FALSE
* ENUM: jpabook.MemberType.Admin (패키지명 포함)
* 엔티티 타입: TYPE(m) = Member (상속 관계에서 사용)

```java
//하드 코딩 하는 경우
String query = " select m.username, 'Hello', TRUE from Member m where m.type = jpql.MemberType.admin";

//파라미터 바인딩
String query = " select m.username, 'Hello', TRUE from Member m where m.type = :userType";

List<Object[]> result = em.createQuery(query)
              .setParameter("userType", MemberType.ADMIN)
              .getResultList();

//Item 중 Book 타입만 조회
Stirng query = "select i from Item i where type(i) = Book";
```

<br>

### 조건식 -CASE 식
* 기본 CASE 식
```java 
String query = "select "
                + "case when m.age <= 10 then '학생요금' "
                     + "when m.age >= 60 then '경로요금' "
                     + "else '일반요금' "
                + "end "
                + "from Member m"
```

* 단순 CASE 식
```java
String query = "select "
                + "case t.name "
                    + "when '팀A' then '인센티브110%' "
                    + "when '팀B' then '인센티브120%' "
                    + "else '인센티브105%' "
                + "end "
                + "from Member m"
```

* COALESCE: 하나씩 조회해서 null이 아니면 반환
```java
//사용자 이름이 없으면 이름 없는 회원을 반환
select coalesce(m.username,'이름 없는 회원') from Member m
```

* NULLIF: 두 값이 같으면 null 반환, 다르면 첫번째 값 반환
```java
//사용자 이름이 ‘관리자’면 null을 반환하고 나머지는 본인의 이름을 반환
select NULLIF(m.username, '관리자') from Member m
```

<br>

### JPQL 기본 함수
* CONCAT: 문자열을 결합
```java
SELECT CONCAT(e.firstName, ' ', e.lastName) FROM Employee e
```
* SUBSTRING: 문자열의 일부를 추출
```java
SELECT SUBSTRING(e.firstName, 1, 3) FROM Employee e
```
* TRIM: 문자열의 앞뒤 공백을 제거
```java
SELECT TRIM(e.firstName) FROM Employee e
```

* LOWER, UPPER: 각각 소문자 및 대문자로 변환
```java
SELECT LOWER(e.firstName) FROM Employee e
```

* LENGTH: 문자열의 길이를 반환
```java
SELECT LENGTH(e.firstName) FROM Employee e
```

* LOCATE: 문자열에서 특정 문자열이나 문자의 위치를 찾음

```java
SELECT LOCATE('John', e.firstName) FROM Employee e
```
* ABS, SQRT, MOD: 각각 절대값, 제곱근, 나머지를 계산

```java
SELECT ABS(e.salary) FROM Employee e
```
* SIZE, INDEX (JPA 용도): 컬렉션의 크기 또는 인덱스를 반환
```java
SELECT SIZE(e.projects) FROM Employee e
```

* 사용자 정의 함수 호출
```java
//사용하는 db의 direct를 상속 받아 생성자에 resgisterFunction을 통해 등록한 후 setting에 반영
select function('group_concat', i.name) from Item i
```